/**
 * Utility commands for sweetch
 * doctor, path, test, edit, clone, rename
 */

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import chalk from 'chalk';
import inquirer from 'inquirer';
import { execFile } from 'child_process';
import { promisify } from 'util';
import { ConfigManager, ProfileConfig } from './config';
import { getCLI } from './clis';
import { getProvider } from './providers';
import { detectInstalledCLIs } from './cliDetection';

const execFileAsync = promisify(execFile);

/**
 * Check if sweetch bin directory is in PATH
 */
export function isInPath(binDir: string): boolean {
  const pathEnv = process.env.PATH || '';
  const paths = pathEnv.split(path.delimiter);
  return paths.some(p => path.resolve(p) === path.resolve(binDir));
}

/**
 * Detect user's shell
 */
export function detectShell(): string {
  const shell = process.env.SHELL || '';

  if (shell.includes('zsh')) return 'zsh';
  if (shell.includes('bash')) return 'bash';
  if (shell.includes('fish')) return 'fish';

  // Default to bash on Unix, cmd on Windows
  return process.platform === 'win32' ? 'cmd' : 'bash';
}

/**
 * Get shell RC file path
 */
export function getShellRCFile(): string {
  const shell = detectShell();
  const home = os.homedir();

  const rcFiles: Record<string, string> = {
    zsh: path.join(home, '.zshrc'),
    bash: path.join(home, '.bashrc'),
    fish: path.join(home, '.config', 'fish', 'config.fish'),
    cmd: '' // Windows doesn't have RC file in same way
  };

  return rcFiles[shell] || path.join(home, '.bashrc');
}

/**
 * sweetch doctor - Health check
 */
export async function runDoctor(): Promise<void> {
  console.log(chalk.bold('\nüè• Sweetch Health Check\n'));

  const config = new ConfigManager();
  const profiles = config.getProfiles();
  const binDir = config.getBinDir();

  // Check Node.js
  console.log(chalk.bold('Environment:'));
  try {
    const nodeVersion = process.version;
    console.log(chalk.green(`  ‚úì Node.js: ${nodeVersion}`));
  } catch {
    console.log(chalk.red('  ‚úó Node.js: Not detected'));
  }

  // Check sweetch version
  try {
    const packagePath = path.join(__dirname, '..', 'package.json');
    const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf-8'));
    console.log(chalk.green(`  ‚úì sweetch: v${pkg.version}`));
  } catch {
    console.log(chalk.gray('  ‚úì sweetch: Development version'));
  }

  // Check PATH
  console.log(chalk.bold('\nPATH Configuration:'));
  if (isInPath(binDir)) {
    const rcFile = getShellRCFile();
    console.log(chalk.green(`  ‚úì ${binDir} is in PATH`));
    console.log(chalk.gray(`    Location: ${rcFile}`));
  } else {
    console.log(chalk.red(`  ‚úó ${binDir} is NOT in PATH`));
    console.log(chalk.yellow(`    Run: ${chalk.bold('sweetch path')} for help`));
  }

  // Check installed CLIs
  console.log(chalk.bold('\nInstalled CLIs:'));
  const detectedCLIs = await detectInstalledCLIs();
  detectedCLIs.forEach(result => {
    if (result.installed) {
      const version = result.version ? ` (${result.version})` : '';
      console.log(chalk.green(`  ‚úì ${result.cli.displayName}${version}`));
    } else {
      console.log(chalk.gray(`  ‚úó ${result.cli.displayName}: Not installed`));
      if (result.cli.installUrl) {
        console.log(chalk.gray(`    Install: ${result.cli.installUrl}`));
      }
    }
  });

  // Check profiles
  console.log(chalk.bold(`\nProfiles (${profiles.length}):`));
  if (profiles.length === 0) {
    console.log(chalk.gray('  No profiles configured yet'));
    console.log(chalk.gray(`  Run: ${chalk.bold('sweetch add')} to add a provider`));
  } else {
    for (const profile of profiles) {
      const provider = getProvider(profile.provider);
      const wrapperPath = path.join(binDir, profile.commandName);
      const profileDir = config.getProfileDir(profile.commandName);
      const settingsPath = path.join(profileDir, 'settings.json');

      const wrapperExists = fs.existsSync(wrapperPath);
      const wrapperExecutable = wrapperExists &&
        (fs.statSync(wrapperPath).mode & parseInt('111', 8)) !== 0;
      const configExists = fs.existsSync(settingsPath);

      if (wrapperExecutable && configExists) {
        console.log(chalk.green(`  ‚úì ${profile.commandName} ‚Üí ${provider?.displayName}`));
      } else {
        console.log(chalk.yellow(`  ‚ö† ${profile.commandName} ‚Üí ${provider?.displayName}`));
        if (!wrapperExists) {
          console.log(chalk.gray(`    Missing wrapper script`));
        } else if (!wrapperExecutable) {
          console.log(chalk.gray(`    Wrapper not executable`));
        }
        if (!configExists) {
          console.log(chalk.gray(`    Missing config file`));
        }
      }
    }
  }

  // Summary
  const hasIssues = !isInPath(binDir) ||
    profiles.some(p => {
      const wrapperPath = path.join(binDir, p.commandName);
      return !fs.existsSync(wrapperPath);
    });

  console.log();
  if (hasIssues) {
    console.log(chalk.yellow('‚ö†Ô∏è  Some issues detected. See above for details.\n'));
  } else {
    console.log(chalk.green('‚úÖ Everything looks good! üéâ\n'));
  }
}

/**
 * sweetch path - PATH configuration helper
 */
export async function runPath(): Promise<void> {
  console.log(chalk.bold('\nüìç PATH Configuration\n'));

  const config = new ConfigManager();
  const binDir = config.getBinDir();
  const inPath = isInPath(binDir);
  const shell = detectShell();
  const rcFile = getShellRCFile();

  if (inPath) {
    console.log(chalk.green(`Status: ‚úì Configured`));
    console.log(chalk.gray(`  ${binDir} is in your PATH`));
    console.log(chalk.gray(`  Shell: ${shell}`));
    console.log();
    return;
  }

  console.log(chalk.yellow(`Status: ‚úó Not configured`));
  console.log(chalk.gray(`  ${binDir} is not in your PATH\n`));

  console.log(chalk.bold('To use your commands, add this to your shell:\n'));

  const exportCmd = `export PATH="$HOME/.sweech/bin:$PATH"`;

  if (shell === 'zsh') {
    console.log(chalk.cyan(`  # For zsh (default on macOS)`));
    console.log(chalk.white(`  echo '${exportCmd}' >> ~/.zshrc`));
    console.log(chalk.white(`  source ~/.zshrc\n`));
  } else if (shell === 'bash') {
    console.log(chalk.cyan(`  # For bash`));
    console.log(chalk.white(`  echo '${exportCmd}' >> ~/.bashrc`));
    console.log(chalk.white(`  source ~/.bashrc\n`));
  } else if (shell === 'fish') {
    console.log(chalk.cyan(`  # For fish`));
    console.log(chalk.white(`  set -Ua fish_user_paths $HOME/.sweech/bin`));
    console.log(chalk.white(`  # Or add to ~/.config/fish/config.fish\n`));
  }

  // Offer to add automatically
  const { autoAdd } = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'autoAdd',
      message: 'Would you like sweetch to add this automatically?',
      default: false
    }
  ]);

  if (autoAdd && rcFile) {
    try {
      // Check if already present
      if (fs.existsSync(rcFile)) {
        const content = fs.readFileSync(rcFile, 'utf-8');
        if (!content.includes('.sweech/bin')) {
          fs.appendFileSync(rcFile, `\n# Added by sweetch\n${exportCmd}\n`);
          console.log(chalk.green(`\n‚úì Added to ${rcFile}`));
          console.log(chalk.yellow(`\nRestart your terminal or run: ${chalk.bold(`source ${rcFile}`)}\n`));
        } else {
          console.log(chalk.green(`\n‚úì Already in ${rcFile}`));
          console.log(chalk.yellow(`\nRestart your terminal or run: ${chalk.bold(`source ${rcFile}`)}\n`));
        }
      } else {
        fs.appendFileSync(rcFile, `\n# Added by sweetch\n${exportCmd}\n`);
        console.log(chalk.green(`\n‚úì Added to ${rcFile}`));
        console.log(chalk.yellow(`\nRestart your terminal or run: ${chalk.bold(`source ${rcFile}`)}\n`));
      }
    } catch (error: any) {
      console.error(chalk.red(`\nFailed to update ${rcFile}:`, error.message));
      console.log(chalk.gray('Please add manually using the commands above.\n'));
    }
  }
}

/**
 * sweetch test - Test provider connection
 */
export async function runTest(commandName: string): Promise<void> {
  const config = new ConfigManager();
  const profiles = config.getProfiles();
  const profile = profiles.find(p => p.commandName === commandName);

  if (!profile) {
    console.error(chalk.red(`\nProfile '${commandName}' not found\n`));
    process.exit(1);
  }

  const provider = getProvider(profile.provider);
  const cli = getCLI(profile.cliType);

  console.log(chalk.bold(`\nüß™ Testing ${commandName} (${provider?.displayName})...\n`));

  // Check configuration
  process.stdout.write(chalk.gray('Checking configuration...        '));
  const profileDir = config.getProfileDir(commandName);
  const settingsPath = path.join(profileDir, 'settings.json');
  const wrapperPath = path.join(config.getBinDir(), commandName);

  if (!fs.existsSync(settingsPath)) {
    console.log(chalk.red('‚úó'));
    console.error(chalk.red(`\nConfig file not found: ${settingsPath}\n`));
    process.exit(1);
  }

  if (!fs.existsSync(wrapperPath)) {
    console.log(chalk.red('‚úó'));
    console.error(chalk.red(`\nWrapper script not found: ${wrapperPath}\n`));
    process.exit(1);
  }

  console.log(chalk.green('‚úì'));

  // Test CLI installation
  process.stdout.write(chalk.gray('Checking CLI installation...     '));
  try {
    await execFileAsync(cli?.command || 'claude', ['--version'], { timeout: 5000 });
    console.log(chalk.green('‚úì'));
  } catch {
    console.log(chalk.red('‚úó'));
    console.error(chalk.red(`\n${cli?.displayName} is not installed or not in PATH\n`));
    process.exit(1);
  }

  // Note: We can't actually test the API without making a real request
  // which would require the CLI's authentication flow
  console.log(chalk.gray('Testing API connection...        ') + chalk.yellow('‚äò Skipped'));
  console.log(chalk.gray('  (Requires CLI authentication flow)\n'));

  console.log(chalk.green('‚úÖ Configuration is valid!\n'));
  console.log(chalk.gray('Configuration:'));
  console.log(chalk.gray(`  Provider: ${provider?.displayName}`));
  console.log(chalk.gray(`  Model: ${profile.model}`));
  console.log(chalk.gray(`  Config: ${profileDir}`));
  console.log(chalk.gray(`  Wrapper: ${wrapperPath}\n`));
  console.log(chalk.cyan(`To use: ${chalk.bold(commandName)}\n`));
}

/**
 * sweetch edit - Edit profile configuration
 */
export async function runEdit(commandName: string): Promise<void> {
  const config = new ConfigManager();
  const profiles = config.getProfiles();
  const profile = profiles.find(p => p.commandName === commandName);

  if (!profile) {
    console.error(chalk.red(`\nProfile '${commandName}' not found\n`));
    process.exit(1);
  }

  const provider = getProvider(profile.provider);

  console.log(chalk.bold(`\n‚úèÔ∏è  Edit ${commandName}\n`));
  console.log(chalk.gray('Current configuration:'));
  console.log(chalk.gray(`  Provider: ${provider?.displayName}`));
  console.log(chalk.gray(`  Model: ${profile.model}`));
  const authMethod = profile.oauth ? 'OAuth' : 'API Key';
  const authDisplay = profile.apiKey
    ? `API Key: ${profile.apiKey.substring(0, 10)}***`
    : `OAuth (${profile.oauth?.provider})`;
  console.log(chalk.gray(`  Auth: ${authDisplay}`));
  console.log();

  const { field } = await inquirer.prompt([
    {
      type: 'list',
      name: 'field',
      message: 'What would you like to edit?',
      choices: [
        { name: 'API Key', value: 'apiKey' },
        { name: 'Model', value: 'model' },
        { name: 'Base URL', value: 'baseUrl' },
        { name: 'Cancel', value: 'cancel' }
      ]
    }
  ]);

  if (field === 'cancel') {
    console.log(chalk.yellow('\nCancelled\n'));
    return;
  }

  let newValue: string;

  if (field === 'apiKey') {
    const answer = await inquirer.prompt([
      {
        type: 'password',
        name: 'value',
        message: 'Enter new API key:',
        mask: '*',
        validate: (input: string) => input.trim().length > 0 || 'API key required'
      }
    ]);
    newValue = answer.value.trim();
  } else if (field === 'model') {
    const answer = await inquirer.prompt([
      {
        type: 'input',
        name: 'value',
        message: 'Enter new model name:',
        default: profile.model,
        validate: (input: string) => input.trim().length > 0 || 'Model name required'
      }
    ]);
    newValue = answer.value.trim();
  } else if (field === 'baseUrl') {
    const answer = await inquirer.prompt([
      {
        type: 'input',
        name: 'value',
        message: 'Enter new base URL:',
        default: profile.baseUrl,
        validate: (input: string) => input.trim().length > 0 || 'Base URL required'
      }
    ]);
    newValue = answer.value.trim();
  } else {
    return;
  }

  // Update profile
  profile[field as keyof ProfileConfig] = newValue as any;

  // Save to config.json
  const allProfiles = profiles.map(p =>
    p.commandName === commandName ? profile : p
  );
  fs.writeFileSync(config.getConfigFile(), JSON.stringify(allProfiles, null, 2));

  // Update settings.json
  if (provider) {
    config.createProfileConfig(commandName, provider, profile.apiKey, profile.cliType);
  }

  console.log(chalk.green(`\n‚úì Updated ${field} for ${commandName}\n`));
}

/**
 * sweetch clone - Clone an existing profile
 */
export async function runClone(sourceName: string, targetName: string): Promise<void> {
  const config = new ConfigManager();
  const profiles = config.getProfiles();
  const source = profiles.find(p => p.commandName === sourceName);

  if (!source) {
    console.error(chalk.red(`\nProfile '${sourceName}' not found\n`));
    process.exit(1);
  }

  if (profiles.some(p => p.commandName === targetName)) {
    console.error(chalk.red(`\nProfile '${targetName}' already exists\n`));
    process.exit(1);
  }

  console.log(chalk.bold(`\nüìã Cloning ${sourceName} ‚Üí ${targetName}...\n`));

  const { useSameKey } = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'useSameKey',
      message: 'Use same API key?',
      default: true
    }
  ]);

  let apiKey = source.apiKey;

  if (!useSameKey) {
    const answer = await inquirer.prompt([
      {
        type: 'password',
        name: 'apiKey',
        message: 'Enter API key for new profile:',
        mask: '*',
        validate: (input: string) => input.trim().length > 0 || 'API key required'
      }
    ]);
    apiKey = answer.apiKey.trim();
  }

  // Create new profile
  const newProfile: ProfileConfig = {
    ...source,
    name: targetName,
    commandName: targetName,
    apiKey,
    createdAt: new Date().toISOString()
  };

  config.addProfile(newProfile);

  const provider = getProvider(source.provider);
  const cli = getCLI(source.cliType);
  if (provider && cli) {
    config.createProfileConfig(targetName, provider, apiKey, cli.name);
  }
  if (cli) {
    config.createWrapperScript(targetName, cli);
  }

  console.log(chalk.green(`\n‚úì Created ${targetName} (${provider?.displayName})\n`));
}

/**
 * sweetch rename - Rename a profile
 */
export async function runRename(oldName: string, newName: string): Promise<void> {
  const config = new ConfigManager();
  const profiles = config.getProfiles();
  const profile = profiles.find(p => p.commandName === oldName);

  if (!profile) {
    console.error(chalk.red(`\nProfile '${oldName}' not found\n`));
    process.exit(1);
  }

  if (profiles.some(p => p.commandName === newName)) {
    console.error(chalk.red(`\nProfile '${newName}' already exists\n`));
    process.exit(1);
  }

  console.log(chalk.bold(`\n‚úèÔ∏è  Renaming ${oldName} ‚Üí ${newName}...\n`));

  // Remove old
  const oldProfileDir = config.getProfileDir(oldName);
  const oldWrapperPath = path.join(config.getBinDir(), oldName);

  // Update profile
  profile.name = newName;
  profile.commandName = newName;

  // Save updated profiles
  const updatedProfiles = profiles.map(p =>
    p.commandName === oldName ? profile : p
  );
  fs.writeFileSync(config.getConfigFile(), JSON.stringify(updatedProfiles, null, 2));

  // Rename profile directory
  const newProfileDir = config.getProfileDir(newName);
  if (fs.existsSync(oldProfileDir)) {
    fs.renameSync(oldProfileDir, newProfileDir);
  }

  // Remove old wrapper and create new one
  if (fs.existsSync(oldWrapperPath)) {
    fs.unlinkSync(oldWrapperPath);
  }

  const cli = getCLI(profile.cliType);
  if (cli) {
    config.createWrapperScript(newName, cli);
  }

  console.log(chalk.green(`‚úì Renamed ${oldName} ‚Üí ${newName}\n`));
  console.log(chalk.gray('  Command: ' + newName));
  console.log(chalk.gray('  Config: ' + newProfileDir));
  console.log();
}
